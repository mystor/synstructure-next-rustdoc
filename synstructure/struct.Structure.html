<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Structure` struct in crate `synstructure`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Structure">

    <title>synstructure::Structure - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc struct">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'>Struct Structure</p><div class="block items"><ul><li><a href="#methods">Methods</a></li></ul></div><p class='location'><a href='index.html'>synstructure</a></p><script>window.sidebarCurrent = {name: 'Structure', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>synstructure</a>::<wbr><a class="struct" href=''>Structure</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/synstructure/lib.rs.html#653-657' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Structure&lt;'a&gt; { /* fields omitted */ }</pre><div class='docblock'><p>A wrapper around a <code>syn</code> <code>DeriveInput</code> which provides utilities for creating
custom derive trait implementations.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl&lt;'a&gt; <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/synstructure/lib.rs.html#659-1297' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new' class="method"><span id='new.v' class='invisible'><code>fn <a href='#method.new' class='fnname'>new</a>(ast: &amp;'a <a class="struct" href="../syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a>) -&gt; Self</code></span></h4>
<div class='docblock'><p>Create a new <code>Structure</code> with the variants and fields from the passed-in
<code>DeriveInput</code>.</p>
</div><h4 id='method.variants' class="method"><span id='variants.v' class='invisible'><code>fn <a href='#method.variants' class='fnname'>variants</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="struct" href="../synstructure/struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'a&gt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></span></h4>
<div class='docblock'><p>Returns a slice of the variants in this Structure.</p>
</div><h4 id='method.variants_mut' class="method"><span id='variants_mut.v' class='invisible'><code>fn <a href='#method.variants_mut' class='fnname'>variants_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="struct" href="../synstructure/struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'a&gt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></span></h4>
<div class='docblock'><p>Returns a mut slice of the variants in this Structure.</p>
</div><h4 id='method.ast' class="method"><span id='ast.v' class='invisible'><code>fn <a href='#method.ast' class='fnname'>ast</a>(&amp;self) -&gt; &amp;'a <a class="struct" href="../syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a></code></span></h4>
<div class='docblock'><p>Returns a reference to the underlying <code>syn</code> AST node which this
<code>Structure</code> was created from.</p>
</div><h4 id='method.omitted_variants' class="method"><span id='omitted_variants.v' class='invisible'><code>fn <a href='#method.omitted_variants' class='fnname'>omitted_variants</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>True if any variants were omitted due to a <code>filter_variants</code> call.</p>
</div><h4 id='method.each' class="method"><span id='each.v' class='invisible'><code>fn <a href='#method.each' class='fnname'>each</a>&lt;F, R&gt;(&amp;self, f: F) -&gt; <a class="struct" href="../quote/tokens/struct.Tokens.html" title="struct quote::tokens::Tokens">Tokens</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../synstructure/struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>) -&gt; R,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,&nbsp;</span></code></span></h4>
<div class='docblock'><p>Runs the passed-in function once for each bound field, passing in a <code>BindingInfo</code>.
and generating <code>match</code> arms which evaluate the returned tokens.</p>

<p>This method will ignore variants or fields which are ignored through the
<code>filter</code> and <code>filter_variant</code> methods.</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="ident">parse_derive_input</span>(<span class="string">r#&quot;
    enum A {
        B(i32, i32),
        C(u32),
    }
&quot;#</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="attribute">#<span class="ident">bi</span>))),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="ident">__binding_1</span>,) <span class="op">=&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_1</span>) }
        }
        <span class="ident">A</span>::<span class="ident">C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) <span class="op">=&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
    }
);</pre>
</div><h4 id='method.fold' class="method"><span id='fold.v' class='invisible'><code>fn <a href='#method.fold' class='fnname'>fold</a>&lt;F, I, R&gt;(&amp;self, init: I, f: F) -&gt; <a class="struct" href="../quote/tokens/struct.Tokens.html" title="struct quote::tokens::Tokens">Tokens</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="struct" href="../quote/tokens/struct.Tokens.html" title="struct quote::tokens::Tokens">Tokens</a>, &amp;<a class="struct" href="../synstructure/struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>) -&gt; R,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,&nbsp;</span></code></span></h4>
<div class='docblock'><p>Runs the passed-in function once for each bound field, passing in the
result of the previous call, and a <code>BindingInfo</code>. generating <code>match</code>
arms which evaluate to the resulting tokens.</p>

<p>This method will ignore variants or fields which are ignored through the
<code>filter</code> and <code>filter_variant</code> methods.</p>

<p>If a variant has been ignored, it will return the <code>init</code> value.</p>

<h1 id='example-1' class='section-header'><a href='#example-1'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="ident">parse_derive_input</span>(<span class="string">r#&quot;
    enum A {
        B(i32, i32),
        C(u32),
    }
&quot;#</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">fold</span>(<span class="macro">quote</span><span class="macro">!</span>(<span class="number">0</span>), <span class="op">|</span><span class="ident">acc</span>, <span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="attribute">#<span class="ident">acc</span> <span class="op">+</span> <span class="attribute">#<span class="ident">bi</span>)),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="ident">__binding_1</span>,) <span class="op">=&gt;</span> {
            <span class="number">0</span> <span class="op">+</span> <span class="ident">__binding_0</span> <span class="op">+</span> <span class="ident">__binding_1</span>
        }
        <span class="ident">A</span>::<span class="ident">C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) <span class="op">=&gt;</span> {
            <span class="number">0</span> <span class="op">+</span> <span class="ident">__binding_0</span>
        }
    }
);</pre>
</div><h4 id='method.each_variant' class="method"><span id='each_variant.v' class='invisible'><code>fn <a href='#method.each_variant' class='fnname'>each_variant</a>&lt;F, R&gt;(&amp;self, f: F) -&gt; <a class="struct" href="../quote/tokens/struct.Tokens.html" title="struct quote::tokens::Tokens">Tokens</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../synstructure/struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>) -&gt; R,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,&nbsp;</span></code></span></h4>
<div class='docblock'><p>Runs the passed-in function once for each variant, passing in a
<code>VariantInfo</code>. and generating <code>match</code> arms which evaluate the returned
tokens.</p>

<p>This method will ignore variants and not bind fields which are ignored
through the <code>filter</code> and <code>filter_variant</code> methods.</p>

<h1 id='example-2' class='section-header'><a href='#example-2'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="ident">parse_derive_input</span>(<span class="string">r#&quot;
    enum A {
        B(i32, i32),
        C(u32),
    }
&quot;#</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each_variant</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span>;
        <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="macro">stringify</span><span class="macro">!</span>(<span class="attribute">#<span class="ident">name</span>)))
    }),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="ident">__binding_1</span>,) <span class="op">=&gt;</span> {
            <span class="macro">println</span><span class="macro">!</span>(<span class="macro">stringify</span><span class="macro">!</span>(<span class="ident">B</span>))
        }
        <span class="ident">A</span>::<span class="ident">C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) <span class="op">=&gt;</span> {
            <span class="macro">println</span><span class="macro">!</span>(<span class="macro">stringify</span><span class="macro">!</span>(<span class="ident">C</span>))
        }
    }
);</pre>
</div><h4 id='method.filter' class="method"><span id='filter.v' class='invisible'><code>fn <a href='#method.filter' class='fnname'>filter</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../synstructure/struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,&nbsp;</span></code></span></h4>
<div class='docblock'><p>Filter the bindings created by this <code>Structure</code> object. This has 2 effects:</p>

<ul>
<li><p>The bindings will no longer appear in match arms generated by methods
on this <code>Structure</code> or its subobjects.</p></li>
<li><p>Impl blocks created with the <code>bound_impl</code> or <code>unsafe_bound_impl</code>
method only consider type parameters referenced in the types of
non-filtered fields.</p></li>
</ul>

<h1 id='example-3' class='section-header'><a href='#example-3'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="ident">parse_derive_input</span>(<span class="string">r#&quot;
    enum A {
        B{ a: i32, b: i32 },
        C{ a: u32 },
    }
&quot;#</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> { <span class="ident">bi</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">==</span> <span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>.<span class="ident">into</span>()) });

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="attribute">#<span class="ident">bi</span>))),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">__binding_0</span>, .. } <span class="op">=&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
        <span class="ident">A</span>::<span class="ident">C</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">__binding_0</span>, } <span class="op">=&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
    }
);</pre>
</div><h4 id='method.filter_variants' class="method"><span id='filter_variants.v' class='invisible'><code>fn <a href='#method.filter_variants' class='fnname'>filter_variants</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../synstructure/struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,&nbsp;</span></code></span></h4>
<div class='docblock'><p>Filter the variants matched by this <code>Structure</code> object. This has 2 effects:</p>

<ul>
<li><p>Match arms destructuring these variants will no longer be generated by
methods on this <code>Structure</code></p></li>
<li><p>Impl blocks created with the <code>bound_impl</code> or <code>unsafe_bound_impl</code>
method only consider type parameters referenced in the types of
fields in non-fitered variants.</p></li>
</ul>

<h1 id='example-4' class='section-header'><a href='#example-4'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="ident">parse_derive_input</span>(<span class="string">r#&quot;
    enum A {
        B(i32, i32),
        C(u32),
    }
&quot;#</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="attribute">#<span class="ident">bi</span>))),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) <span class="op">=&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
        _ <span class="op">=&gt;</span> {}
    }
);</pre>
</div><h4 id='method.remove_variant' class="method"><span id='remove_variant.v' class='invisible'><code>fn <a href='#method.remove_variant' class='fnname'>remove_variant</a>(&amp;mut self, idx: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; &amp;mut Self</code></span></h4>
<div class='docblock'><p>Remove the variant at the given index.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>Panics if the index is out of range.</p>
</div><h4 id='method.bind_with' class="method"><span id='bind_with.v' class='invisible'><code>fn <a href='#method.bind_with' class='fnname'>bind_with</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../synstructure/struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>) -&gt; <a class="enum" href="../synstructure/enum.BindStyle.html" title="enum synstructure::BindStyle">BindStyle</a>,&nbsp;</span></code></span></h4>
<div class='docblock'><p>Updates the <code>BindStyle</code> for each of the passed-in fields by calling the
passed-in function for each <code>BindingInfo</code>.</p>

<h1 id='example-5' class='section-header'><a href='#example-5'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="ident">parse_derive_input</span>(<span class="string">r#&quot;
    enum A {
        B(i32, i32),
        C(u32),
    }
&quot;#</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">bind_with</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="ident">BindStyle</span>::<span class="ident">RefMut</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="attribute">#<span class="ident">bi</span>))),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>(<span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">__binding_1</span>,) <span class="op">=&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_1</span>) }
        }
        <span class="ident">A</span>::<span class="ident">C</span>(<span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">__binding_0</span>,) <span class="op">=&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
    }
);</pre>
</div><h4 id='method.binding_name' class="method"><span id='binding_name.v' class='invisible'><code>fn <a href='#method.binding_name' class='fnname'>binding_name</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../syn/data/struct.Field.html" title="struct syn::data::Field">Field</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../syn/ident/struct.Ident.html" title="struct syn::ident::Ident">Ident</a>,&nbsp;</span></code></span></h4>
<div class='docblock'><p>Updates the binding name for each fo the passed-in fields by calling the
passed-in function for each <code>BindingInfo</code>.</p>

<p>The function will be called with the <code>BindingInfo</code> and its index in the
enclosing variant.</p>

<p>The default name is <code>__binding_{}</code> where <code>{}</code> is replaced with an
increasing number.</p>

<h1 id='example-6' class='section-header'><a href='#example-6'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="ident">parse_derive_input</span>(<span class="string">r#&quot;
    enum A {
        B{ a: i32, b: i32 },
        C{ a: u32 },
    }
&quot;#</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">binding_name</span>(<span class="op">|</span><span class="ident">bi</span>, <span class="ident">i</span><span class="op">|</span> <span class="ident">bi</span>.<span class="ident">ident</span>.<span class="ident">clone</span>().<span class="ident">unwrap</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="attribute">#<span class="ident">bi</span>))),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">a</span>, <span class="ident">b</span>: <span class="kw-2">ref</span> <span class="ident">b</span>, } <span class="op">=&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">a</span>) }
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">b</span>) }
        }
        <span class="ident">A</span>::<span class="ident">C</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">a</span>, } <span class="op">=&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">a</span>) }
        }
    }
);</pre>
</div><h4 id='method.referenced_ty_params' class="method"><span id='referenced_ty_params.v' class='invisible'><code>fn <a href='#method.referenced_ty_params' class='fnname'>referenced_ty_params</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;&amp;'a <a class="struct" href="../syn/ident/struct.Ident.html" title="struct syn::ident::Ident">Ident</a>&gt;</code></span></h4>
<div class='docblock'><p>Returns a list of the type parameters which are refrenced in the types
of non-filtered fields / variants.</p>

<h1 id='caveat' class='section-header'><a href='#caveat'>Caveat</a></h1>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>

<h1 id='example-7' class='section-header'><a href='#example-7'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="ident">parse_derive_input</span>(<span class="string">r#&quot;
    enum A&lt;T, U&gt; {
        B(T, i32),
        C(Option&lt;U&gt;),
    }
&quot;#</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!=</span> <span class="string">&quot;C&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">referenced_ty_params</span>(),
    <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span>(<span class="ident">syn</span>::<span class="ident">Ident</span>::<span class="ident">from</span>(<span class="string">&quot;T&quot;</span>))]
);</pre>
</div><h4 id='method.add_trait_bounds' class="method"><span id='add_trait_bounds.v' class='invisible'><code>fn <a href='#method.add_trait_bounds' class='fnname'>add_trait_bounds</a>(&amp;self, path: <a class="struct" href="../syn/ty/struct.Path.html" title="struct syn::ty::Path">Path</a>, preds: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../syn/generics/enum.WherePredicate.html" title="enum syn::generics::WherePredicate">WherePredicate</a>&gt;)</code></span></h4>
<div class='docblock'><p>Add trait bounds for a trait with the given path for each type parmaeter
referenced in the types of non-filtered fields.</p>

<h1 id='caveat-1' class='section-header'><a href='#caveat-1'>Caveat</a></h1>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
</div><h4 id='method.bound_impl' class="method"><span id='bound_impl.v' class='invisible'><code>fn <a href='#method.bound_impl' class='fnname'>bound_impl</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(&amp;self, path: P, body: B) -&gt; <a class="struct" href="../quote/tokens/struct.Tokens.html" title="struct quote::tokens::Tokens">Tokens</a></code></span></h4>
<div class='docblock'><p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the trait <code>path</code>.</p>

<p>This method also adds where clauses to the impl requiring that all
referenced type parmaeters implement the trait <code>path</code>.</p>

<h1 id='caveat-2' class='section-header'><a href='#caveat-2'>Caveat</a></h1>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>

<h1 id='panics-1' class='section-header'><a href='#panics-1'>Panics</a></h1>
<p>Panics if the path string parameter is not a valid rust path.</p>

<h1 id='example-8' class='section-header'><a href='#example-8'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="ident">parse_derive_input</span>(<span class="string">r#&quot;
    enum A&lt;T, U&gt; {
        B(T),
        C(Option&lt;U&gt;),
    }
&quot;#</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">bound_impl</span>(<span class="string">&quot;::krate::Trait&quot;</span>, <span class="macro">quote</span><span class="macro">!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> ::<span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
            <span class="kw">where</span> <span class="ident">U</span>: ::<span class="ident">krate</span>::<span class="ident">Trait</span>
        {
            <span class="kw">fn</span> <span class="ident">a</span>() {}
        }
    }
);</pre>
</div><h4 id='method.unsafe_bound_impl' class="method"><span id='unsafe_bound_impl.v' class='invisible'><code>fn <a href='#method.unsafe_bound_impl' class='fnname'>unsafe_bound_impl</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;body: B<br>) -&gt; <a class="struct" href="../quote/tokens/struct.Tokens.html" title="struct quote::tokens::Tokens">Tokens</a></code></span></h4>
<div class='docblock'><p>This method is the same as <code>bound_impl</code>, except also includes the
<code>unsafe</code> keyword for implementing unsafe traits.</p>
</div><h4 id='method.unbound_impl' class="method"><span id='unbound_impl.v' class='invisible'><code>fn <a href='#method.unbound_impl' class='fnname'>unbound_impl</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(&amp;self, path: P, body: B) -&gt; <a class="struct" href="../quote/tokens/struct.Tokens.html" title="struct quote::tokens::Tokens">Tokens</a></code></span></h4>
<div class='docblock'><p>This method is like <code>bound_impl</code> but doesn&#39;t add the additional bounds
to the where clause.</p>
</div><h4 id='method.unsafe_unbound_impl' class="method"><span id='unsafe_unbound_impl.v' class='invisible'><code>fn <a href='#method.unsafe_unbound_impl' class='fnname'>unsafe_unbound_impl</a>&lt;P:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;body: B<br>) -&gt; <a class="struct" href="../quote/tokens/struct.Tokens.html" title="struct quote::tokens::Tokens">Tokens</a></code></span></h4>
<div class='docblock'><p>This method is the same as <code>unbound_impl</code>, except also includes the
<code>unsafe</code> keyword for implementing unsafe traits.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "synstructure";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>